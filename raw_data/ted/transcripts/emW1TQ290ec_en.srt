1
0:00:15.26,000 --> 0:00:17,000
Today I'd like to show you

2
0:00:17.26,000 --> 0:00:19,000
the future of the way we make things.

3
0:00:19.26,000 --> 0:00:21,000
I believe that soon our buildings and machines

4
0:00:21.26,000 --> 0:00:23,000
will be self-assembling,

5
0:00:23.26,000 --> 0:00:25,000
replicating and repairing themselves.

6
0:00:25.26,000 --> 0:00:27,000
So I'm going to show you

7
0:00:27.26,000 --> 0:00:29,000
what I believe is the current state of manufacturing,

8
0:00:29.26,000 --> 0:00:32,000
and then compare that to some natural systems.

9
0:00:32.26,000 --> 0:00:35,000
So in the current state of manufacturing, we have skyscrapers --

10
0:00:35.26,000 --> 0:00:37,000
two and a half years [of assembly time],

11
0:00:37.26,000 --> 0:00:39,000
500,000 to a million parts,

12
0:00:39.26,000 --> 0:00:41,000
fairly complex,

13
0:00:41.26,000 --> 0:00:44,000
new, exciting technologies in steel, concrete, glass.

14
0:00:44.26,000 --> 0:00:46,000
We have exciting machines

15
0:00:46.26,000 --> 0:00:48,000
that can take us into space --

16
0:00:48.26,000 --> 0:00:51,000
five years [of assembly time], 2.5 million parts.

17
0:00:51.26,000 --> 0:00:54,000
But on the other side, if you look at the natural systems,

18
0:00:54.26,000 --> 0:00:56,000
we have proteins

19
0:00:56.26,000 --> 0:00:58,000
that have two million types,

20
0:00:58.26,000 --> 0:01:,000
can fold in 10,000 nanoseconds,

21
0:01:00.26,000 --> 0:01:02,000
or DNA with three billion base pairs

22
0:01:02.26,000 --> 0:01:05,000
we can replicate in roughly an hour.

23
0:01:05.26,000 --> 0:01:07,000
So there's all of this complexity

24
0:01:07.26,000 --> 0:01:09,000
in our natural systems,

25
0:01:09.26,000 --> 0:01:11,000
but they're extremely efficient,

26
0:01:11.26,000 --> 0:01:13,000
far more efficient than anything we can build,

27
0:01:13.26,000 --> 0:01:15,000
far more complex than anything we can build.

28
0:01:15.26,000 --> 0:01:17,000
They're far more efficient in terms of energy.

29
0:01:17.26,000 --> 0:01:2,000
They hardly ever make mistakes.

30
0:01:20.26,000 --> 0:01:22,000
And they can repair themselves for longevity.

31
0:01:22.26,000 --> 0:01:25,000
So there's something super interesting about natural systems.

32
0:01:25.26,000 --> 0:01:27,000
And if we can translate that

33
0:01:27.26,000 --> 0:01:29,000
into our built environment,

34
0:01:29.26,000 --> 0:01:31,000
then there's some exciting potential for the way that we build things.

35
0:01:31.26,000 --> 0:01:34,000
And I think the key to that is self-assembly.

36
0:01:34.26,000 --> 0:01:37,000
So if we want to utilize self-assembly in our physical environment,

37
0:01:37.26,000 --> 0:01:39,000
I think there's four key factors.

38
0:01:39.26,000 --> 0:01:41,000
The first is that we need to decode

39
0:01:41.26,000 --> 0:01:43,000
all of the complexity of what we want to build --

40
0:01:43.26,000 --> 0:01:45,000
so our buildings and machines.

41
0:01:45.26,000 --> 0:01:47,000
And we need to decode that into simple sequences --

42
0:01:47.26,000 --> 0:01:49,000
basically the DNA of how our buildings work.

43
0:01:49.26,000 --> 0:01:51,000
Then we need programmable parts

44
0:01:51.26,000 --> 0:01:53,000
that can take that sequence

45
0:01:53.26,000 --> 0:01:56,000
and use that to fold up, or reconfigure.

46
0:01:56.26,000 --> 0:01:59,000
We need some energy that's going to allow that to activate,

47
0:01:59.26,000 --> 0:02:02,000
allow our parts to be able to fold up from the program.

48
0:02:02.26,000 --> 0:02:04,000
And we need some type of error correction redundancy

49
0:02:04.26,000 --> 0:02:07,000
to guarantee that we have successfully built what we want.

50
0:02:07.26,000 --> 0:02:09,000
So I'm going to show you a number of projects

51
0:02:09.26,000 --> 0:02:11,000
that my colleagues and I at MIT are working on

52
0:02:11.26,000 --> 0:02:13,000
to achieve this self-assembling future.

53
0:02:13.26,000 --> 0:02:16,000
The first two are the MacroBot and DeciBot.

54
0:02:16.26,000 --> 0:02:2,000
So these projects are large-scale reconfigurable robots --

55
0:02:20.26,000 --> 0:02:23,000
8 ft., 12 ft. long proteins.

56
0:02:23.26,000 --> 0:02:26,000
They're embedded with mechanical electrical devices, sensors.

57
0:02:26.26,000 --> 0:02:28,000
You decode what you want to fold up into,

58
0:02:28.26,000 --> 0:02:3,000
into a sequence of angles --

59
0:02:30.26,000 --> 0:02:32,000
so negative 120, negative 120, 0, 0,

60
0:02:32.26,000 --> 0:02:35,000
120, negative 120 -- something like that;

61
0:02:35.26,000 --> 0:02:37,000
so a sequence of angles, or turns,

62
0:02:37.26,000 --> 0:02:4,000
and you send that sequence through the string.

63
0:02:40.26,000 --> 0:02:43,000
Each unit takes its message -- so negative 120 --

64
0:02:43.26,000 --> 0:02:45,000
it rotates to that, checks if it got there

65
0:02:45.26,000 --> 0:02:48,000
and then passes it to its neighbor.

66
0:02:48.26,000 --> 0:02:5,000
So these are the brilliant scientists,

67
0:02:50.26,000 --> 0:02:52,000
engineers, designers that worked on this project.

68
0:02:52.26,000 --> 0:02:54,000
And I think it really brings to light:

69
0:02:54.26,000 --> 0:02:56,000
Is this really scalable?

70
0:02:56.26,000 --> 0:02:58,000
I mean, thousands of dollars, lots of man hours

71
0:02:58.26,000 --> 0:03:01,000
made to make this eight-foot robot.

72
0:03:01.26,000 --> 0:03:04,000
Can we really scale this up? Can we really embed robotics into every part?

73
0:03:04.26,000 --> 0:03:06,000
The next one questions that

74
0:03:06.26,000 --> 0:03:08,000
and looks at passive nature,

75
0:03:08.26,000 --> 0:03:11,000
or passively trying to have reconfiguration programmability.

76
0:03:11.26,000 --> 0:03:13,000
But it goes a step further,

77
0:03:13.26,000 --> 0:03:15,000
and it tries to have actual computation.

78
0:03:15.26,000 --> 0:03:17,000
It basically embeds the most fundamental building block of computing,

79
0:03:17.26,000 --> 0:03:19,000
the digital logic gate,

80
0:03:19.26,000 --> 0:03:21,000
directly into your parts.

81
0:03:21.26,000 --> 0:03:23,000
So this is a NAND gate.

82
0:03:23.26,000 --> 0:03:25,000
You have one tetrahedron which is the gate

83
0:03:25.26,000 --> 0:03:27,000
that's going to do your computing,

84
0:03:27.26,000 --> 0:03:29,000
and you have two input tetrahedrons.

85
0:03:29.26,000 --> 0:03:32,000
One of them is the input from the user, as you're building your bricks.

86
0:03:32.26,000 --> 0:03:35,000
The other one is from the previous brick that was placed.

87
0:03:35.26,000 --> 0:03:38,000
And then it gives you an output in 3D space.

88
0:03:38.26,000 --> 0:03:4,000
So what this means

89
0:03:40.26,000 --> 0:03:43,000
is that the user can start plugging in what they want the bricks to do.

90
0:03:43.26,000 --> 0:03:45,000
It computes on what it was doing before

91
0:03:45.26,000 --> 0:03:47,000
and what you said you wanted it to do.

92
0:03:47.26,000 --> 0:03:49,000
And now it starts moving in three-dimensional space --

93
0:03:49.26,000 --> 0:03:51,000
so up or down.

94
0:03:51.26,000 --> 0:03:54,000
So on the left-hand side, [1,1] input equals 0 output, which goes down.

95
0:03:54.26,000 --> 0:03:56,000
On the right-hand side,

96
0:03:56.26,000 --> 0:03:59,000
[0,0] input is a 1 output, which goes up.

97
0:03:59.26,000 --> 0:04:01,000
And so what that really means

98
0:04:01.26,000 --> 0:04:03,000
is that our structures now contain the blueprints

99
0:04:03.26,000 --> 0:04:05,000
of what we want to build.

100
0:04:05.26,000 --> 0:04:08,000
So they have all of the information embedded in them of what was constructed.

101
0:04:08.26,000 --> 0:04:11,000
So that means that we can have some form of self-replication.

102
0:04:11.26,000 --> 0:04:14,000
In this case I call it self-guided replication,

103
0:04:14.26,000 --> 0:04:16,000
because your structure contains the exact blueprints.

104
0:04:16.26,000 --> 0:04:18,000
If you have errors, you can replace a part.

105
0:04:18.26,000 --> 0:04:21,000
All the local information is embedded to tell you how to fix it.

106
0:04:21.26,000 --> 0:04:23,000
So you could have something that climbs along and reads it

107
0:04:23.26,000 --> 0:04:25,000
and can output at one to one.

108
0:04:25.26,000 --> 0:04:27,000
It's directly embedded; there's no external instructions.

109
0:04:27.26,000 --> 0:04:3,000
So the last project I'll show is called Biased Chains,

110
0:04:30.26,000 --> 0:04:33,000
and it's probably the most exciting example that we have right now

111
0:04:33.26,000 --> 0:04:35,000
of passive self-assembly systems.

112
0:04:35.26,000 --> 0:04:37,000
So it takes the reconfigurability

113
0:04:37.26,000 --> 0:04:39,000
and programmability

114
0:04:39.26,000 --> 0:04:42,000
and makes it a completely passive system.

115
0:04:43.26,000 --> 0:04:45,000
So basically you have a chain of elements.

116
0:04:45.26,000 --> 0:04:47,000
Each element is completely identical,

117
0:04:47.26,000 --> 0:04:49,000
and they're biased.

118
0:04:49.26,000 --> 0:04:52,000
So each chain, or each element, wants to turn right or left.

119
0:04:52.26,000 --> 0:04:55,000
So as you assemble the chain, you're basically programming it.

120
0:04:55.26,000 --> 0:04:58,000
You're telling each unit if it should turn right or left.

121
0:04:58.26,000 --> 0:05:01,000
So when you shake the chain,

122
0:05:01.26,000 --> 0:05:03,000
it then folds up

123
0:05:03.26,000 --> 0:05:06,000
into any configuration that you've programmed in --

124
0:05:06.26,000 --> 0:05:08,000
so in this case, a spiral,

125
0:05:08.26,000 --> 0:05:11,000
or in this case,

126
0:05:11.26,000 --> 0:05:14,000
two cubes next to each other.

127
0:05:14.26,000 --> 0:05:16,000
So you can basically program

128
0:05:16.26,000 --> 0:05:18,000
any three-dimensional shape --

129
0:05:18.26,000 --> 0:05:21,000
or one-dimensional, two-dimensional -- up into this chain completely passively.

130
0:05:21.26,000 --> 0:05:23,000
So what does this tell us about the future?

131
0:05:23.26,000 --> 0:05:25,000
I think that it's telling us

132
0:05:25.26,000 --> 0:05:28,000
that there's new possibilities for self-assembly, replication, repair

133
0:05:28.26,000 --> 0:05:31,000
in our physical structures, our buildings, machines.

134
0:05:31.26,000 --> 0:05:33,000
There's new programmability in these parts.

135
0:05:33.26,000 --> 0:05:35,000
And from that you have new possibilities for computing.

136
0:05:35.26,000 --> 0:05:37,000
We'll have spatial computing.

137
0:05:37.26,000 --> 0:05:39,000
Imagine if our buildings, our bridges, machines,

138
0:05:39.26,000 --> 0:05:41,000
all of our bricks could actually compute.

139
0:05:41.26,000 --> 0:05:43,000
That's amazing parallel and distributed computing power,

140
0:05:43.26,000 --> 0:05:45,000
new design possibilities.

141
0:05:45.26,000 --> 0:05:47,000
So it's exciting potential for this.

142
0:05:47.26,000 --> 0:05:49,000
So I think these projects I've showed here

143
0:05:49.26,000 --> 0:05:51,000
are just a tiny step towards this future,

144
0:05:51.26,000 --> 0:05:53,000
if we implement these new technologies

145
0:05:53.26,000 --> 0:05:55,000
for a new self-assembling world.

146
0:05:55.26,000 --> 0:05:57,000
Thank you.

147
0:05:57.26,000 --> 0:05:59,000
(Applause)

